Make a separate "demo_game(.cpp|.h)", where there will be a simple gathering/training skills textgame.








1. Idea: Add 2 different multipliers:
  1. score_multiplier( this is the multiplier that works currently )
  2. success_level_multiplier( this will be multiplied times the success level, that is the value after rounding )

hmm, now that I think of it - maybe this would be too much unnecessary complexity?


in
	d16:cpp:calc_d16_score
currently, a multiply of 0 will clearly ensure the success is always 0, but maybe it should default to 1? or, if multiply is less than 1, then it is calculated normally, but success cannot be raised higher than 1?

*
technical: a slightly more robust way of handling randomness. That is: instead of rolling the dice in definition(creating the RollResult), the dicerolling should. This doesn't seem too important yet, since the whole idea is that the d16 will be rolled always. Also, it would be absolutely funny as heck, if one day I/someone could look back at this comment and say "eh, if only on this faithful date of 2020-05-16T01:29:55+0200 , if only back then you already decoupled dicerolling from creating all those ability_result...). :DD


*
Just thought about an easy way to have multiple counters in ability: AbilityResult will have an array of counter deltas  :DD 
and similarly, an array
I was thinking of holding an std::vector for counter types, but:
1. the logic will be unnecessarily more complicated than a flay array of known size with a for loop
2. Even if it was slightly more "efficient", it would be not by much. When having only a few counter types, the overhead of std::vector will probably be much greater than the 32 bytes of int with value 0



*
Someone might ask: "but why all those arrays, dude?"
I use all those arrays, because it's so easy.
I structured the game in the way, that everything is a simple integer number. Thus, I can just pile on all those arrays(and some vectors).
Currently I'm having mental trouble with available_ability.
Maybe, I will just put an array of bools to represent available_ability?
And then, instead of building the vector of strings for each ability(for the sake of selecting), we can loop over that array, and just build the std::vector<std::string> with push_back on each ability that is_available.
Again, don't prematurely optimize when it would make things harder: if had like a million abilities, then looping over that array could be a problem(but then, there would be many more problems with having that many abilities; i want to stick to few, simple abilitities)
Or, an array of int, to represent level of each available ability, where 0 or less is "unavailable", and everything higher is the proficiency(which could give bonuses or something, for now I should stick with the current challenges, instead of piling on more complexity)



idea that will make for an interesting mechanic: at the end of each round, all rollmods will be recalculated for each entity
This will have 2 effects:
1. gameplay:
"first move" will matter much, much less.
with the current pending idea for handling abilities and combat, it will mean that the effects will get stacked in a particular order, but I'm also thinking about working it all more like a queue: each round a vector_pending_ability_results_to_apply will be iterated over, and then emptied. it could be done also as a stack, but nah I don't think so.
2. code:
all calculations will be stored in one place. my premature_optimization instinct says, that it will be better than the current idea of doing everything a la functional programming. currently, I'm planning to implement 




Area mechanics:
1. "vile aura" all characters in the area are subject every round to poison-dealing effect. This would be for example an ability that is rolled each round on all entities, with stats {add -8 , m  1, counter_type_poison}. This means, that an entity without any poison resistance will be subject to a lot of poison damage. And of course - the entities that are the "natural inhabitants" will have poison resistance at least 8, so that they don't get the ambient damage
